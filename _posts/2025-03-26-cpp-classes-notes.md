## Notes in C++ classes

Switching from C# to C++ means get used to some indiviualities of the language. Class generation in C++ seems harder, because you have to implement more operations by yourself, which are not necessary in C#.

### 'Delete' keyword

In C++, = delete is used to explicitly delete (i.e., disable) a function, preventing it from being called or generated by the compiler.

`Point3d() = delete;  // Default constructor is deleted`

This causes the constructor `Point3d()` to be disabled. You need to use one of the other constructor provided by the class to create it. Delete can be usefull to preven unwated behavior and mark it as error to the compiler.

Other uses of = delete

You can delete any function to prevent its use:
- Disabling copy/move operations (though in your code, they are = default).
- Disabling certain overloads (e.g., preventing implicit conversions).
- Disabling operators (e.g., operator= for a singleton).

### 'Default' keyword

`default` Explicitly tells the compiler to generate the default implementation of a special member function (constructor, destructor, copy/move operations, etc.) and was introduced in C++11. 

`Point3d() = default;  // Compiler generates Point3d(){}`

You are telling the compiler:
1. Generate the default implementation of this function (even if other constructors are user-defined).
2. Follow standard behavior (e.g., member-wise copy for the copy constructor).
3. Optimize better than a hand-written version (compilers may apply special optimizations for = default).

Examples for move/copy operations and destructor:

```
Point3d(const Point3d&) = default;            // Copy constructor
Point3d(Point3d&&) = default;                 // Move constructor
Point3d& operator=(const Point3d&) = default; // Copy assignment
Point3d& operator=(Point3d&&) = default;      // Move assignment

~Point3d() = default;  // Compiler-generated destructor
```

### Copy/Move operators and the rule of five

In C++, copy and move operators are special member functions that control how objects are copied or moved. They are part of the Rule of Five (since C++11), which states that if you define any of these five functions, you should consider defining all of them:
1. Copy Constructor
2. Copy Assignment Operator
3. Move Constructor
4. Move Assignment Operator
5. Destructor

#### 1. Copy Operator 

These create a new object as a copy of an existing one.
Copy Constructor. Called when:
- Passing by value: Point3d p2 = p1;
- Returning by value (if not optimized out).

`Point3d(const Point3d& other) : x(other.x), y(other.y), z(other.z) {}`

or default Version:

`Point3d(const Point3d&) = default; // Member-wise copy`

#### 2. Copy Assignment Operator
Called when assigning an existing object to another:

```
Point3d p1(1, 2, 3);
Point3d p2;
p2 = p1; // Uses copy assignment
```

Syntax:

```
Point3d& operator=(const Point3d& other) {
    x = other.x;
    y = other.y;
    z = other.z;
    return *this;
}
```

or default version: 

```
Point3d& operator=(const Point3d&) = default; // Member-wise copy
```

#### 3. Move Constructor (Efficient Transfer)

These "steal" resources from a temporary object (e.g., from an rvalue).
Called when:
- Constructing from a temporary: Point3d p2 = std::move(p1);
- Returning a local object (if move semantics apply).

When you use move operators (move constructor or move assignment), the standard behavior is to transfer resources from the source (moved-from) object to the destination (moved-to) object. After the move:
- The moved-to object gets the original values of the moved-from object.
- The moved-from object is left in a valid but unspecified state (its members may be modified or reset).

Move semantics transfer ownership of resources (e.g., memory, file handles), but for simple types like double, they just copy the value. The moved-from object is typically left in a "reset" state (e.g., 0 for numbers, nullptr for pointers). Modifying the moved-from object does not affect the moved-to object (unless you intentionally share state, which is rare and dangerous).
Default move operations perform member-wise moves:
- For primitives (int, double), they just copy.
- For move-aware types (e.g., std::string, std::vector), they efficiently transfer resources.

Syntax : 
```
// Custom move constructor (for demonstration)
  Point3d(Point3d&& other) noexcept 
      : x(std::exchange(other.x, 0)),  // Steals 'x' and sets other.x = 0
        y(std::exchange(other.y, 0)), // Steals 'y' and sets other.y = 0
        z(std::exchange(other.z, 0))   // Steals 'z' and sets other.z = 0
  {}
```

Default:
```
Point3d(Point3d&&) = default; // Member-wise move
```

##### 4. Move assignment Operator

Called when assignen from a temporary value:
```
Point3d p1(1, 2, 3);
Point3d p2;
p2 = std::move(p1); // Uses move assignment
```

Syntax:
```
Point3d& operator=(Point3d&& other) noexcept {
    x = std::exchange(other.x, 0);
    y = std::exchange(other.y, 0);
    z = std::exchange(other.z, 0);
    return *this;
}
```

Default:
```
Point3d& operator=(Point3d&&) = default; // Member-wise move
```

#### Best Practices
1. Follow the Rule of Five (if you define one, define all five).
2. Prefer = default when possible (safer and more maintainable).
3. Mark move operations as noexcept (helps STL containers optimize).
4. Delete copy/move operators for non-copyable objects (e.g., mutexes).


